
# 肉桂卷01
https://www.xiaohongshu.com/explore/6358b8dd000000001502e9ef
1. 免揉面团
温牛奶130g
干酵母3g
高筋面粉200g
糖15g
盐4g
黄油15g

2. 肉桂酱：
红糖30g - 20g
肉桂粉5g - 10g
黄油25g

3. 发酵：30° 45分钟
两倍大后，直接擀开，不要揉，擀成25cm*30cm大小
均匀摸酱，卷起来，蘸水封口
均分8块
30° 30分钟，1.5-2倍大

4. 刷牛奶，撒坚果碎，烤箱提前10分钟预热，180°烤20分钟

5. 烤好后淋上乳酪酱：
糖粉20g
牛奶13g
奶油奶酪10g

6. 最后撒上糖粉

# 肉桂卷02
https://www.xiaohongshu.com/explore/644a42450000000013036c4e
1. 免揉面团
牛奶150g
酵母3g
全麦面粉100g
高筋面粉100g
盐2g
糖15g
黄油15g

2. 发酵30°40分钟
3. 肉桂酱
肉桂粉5g
红糖20g
黄油25g

4. 按压排气，擀成长方形35cm*25cm
肉桂酱抹匀，卷起来，切成6份

5. 发酵30°40分钟，1.5倍大
6. 抹上牛奶，烤箱180°烤20分钟


# 智能指针解决了什么问题
https://www.geeksforgeeks.org/smart-pointers-cpp/
* Memory leak 内存泄漏，指针不再使用了但没释放内存
* Dangling Pointers 悬挂指针，指针指向的内存被释放了，但是指针没置零
* Wild Pointers 野指针，指针指向的内容不再有效，或者指针没有初始化
* Buffer Overflow 缓冲区溢出，通过指针写入分配内存之外的内存

# 如何做Code Review
https://mp.weixin.qq.com/s/HoFSNCd1U3eoUqYaQiEgwQ


# 介绍一下现代计算机图形高效渲染的方法论
现代计算机图形高效渲染是指通过优化算法和技术，以最小的计算资源和时间生成逼真且高性能的图像输出。以下是一些现代计算机图形高效渲染的方法论：

1. 并行计算：利用现代图形硬件（如GPU）的并行计算能力，将渲染任务分解为多个并行子任务，并同时执行它们。这样可以提高渲染的速度和效率。

2. 渲染管线优化：图形渲染通常包括多个阶段，如顶点处理、三角形剪裁、光栅化、片段处理等。通过对渲染管线中各个阶段进行优化，如使用更高效的数据结构和算法、减少不必要的计算和内存访问等，可以提高渲染性能。

3. 着色器优化：着色器是渲染管线中的重要组成部分，负责模拟光照、纹理贴图、阴影等效果。通过优化着色器算法和数据布局，可以减少计算复杂度和内存访问，提高着色器执行效率。

4. 纹理压缩：高分辨率纹理占据大量的显存带宽和存储空间。通过使用纹理压缩算法（如基于块的压缩算法）对纹理进行压缩，可以减少内存带宽和存储需求，提高渲染效率。

5. 裁剪和可视性检测优化：在渲染过程中，通过裁剪和可视性检测技术排除不可见的对象和图元，可以减少不必要的渲染工作，提高渲染性能。

6. Level of Detail（LOD）技术：针对远离相机的对象，可以使用较低细节级别的模型和纹理来代替高细节级别的模型和纹理，以减少计算和内存开销，同时保持一定程度的渲染质量。

7. GPU计算：利用GPU的通用计算能力，将一些与图形渲染相关的计算任务移至GPU执行，例如物理模拟、粒子系统、阴影计算等。这样可以释放CPU负担，提高整体的渲染性能。

8. 前向渲染与延迟渲染：前向渲染适合处理少量光源和非复杂场景，而延迟渲染适合处理大量光源和复杂场景。根据具体需求选择合适的渲染技术，以提高渲染性能。

除了上述方法，还有很多其他的优化技术和算法可用于高效渲染。在实际应用中，根据具体场景和需求，可以结合多种技术和策略进行综合优化，以达到更好的图形渲染性能。

# 线程池
https://www.cnblogs.com/carsonzhu/p/16799198.html
* 基本实现
```
class ThreadPool {
public:
    explicit ThreadPool(size_t threads = std::thread::hardware_concurrency());
​
    template<typename F, typename... Args>
    auto enqueue(F &&f, Args &&...args);
​
    ~ThreadPool();
​
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;
};
```
## 线程池大小如何设置
* CPU密集型任务：频繁切换上下线程是不明智的，此时应该设置一个较小的线程数，比如CPU的数目加1；
* IO密集型任务：IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1。

## 配置线程池大小的原则-阻抗公式
```
N = CPU数量
P = CPU繁忙时间 / 总运行时间   // 0 < P <=1
T = 所需设置线程数
T = N / P
```

## OpenAI：阻抗公式
在线程池中，阻抗公式不是一个常见的概念。线程池是一种并发编程技术，用于管理和复用线程资源，以提高应用程序的性能和响应能力。它通常包含了以下几个关键参数：

并行度（Parallelism）：表示线程池中同时执行任务的线程数量。较高的并行度可以提高任务的并发执行能力，但也会增加线程调度和资源开销。
最大线程数（Max Threads）：线程池允许创建的最大线程数量。超过此数量的任务将排队等待执行。
队列容量（Queue Capacity）：线程池任务队列可以容纳的最大任务数。当任务数量达到队列容量时，新的任务将被拒绝或采取其他策略进行处理。
饱和策略（Saturation Policy）：用于处理任务提交速度超过线程池处理能力的情况。常见的饱和策略包括直接执行、拒绝任务、丢弃任务等。
这些参数会影响线程池的性能和效率，但没有一个明确的公式来描述它们之间的关系为阻抗公式。线程池的设计和调优通常需要根据具体应用场景和需求进行调整和优化。

在实际使用线程池时，你可以根据任务的特性、系统资源和性能需求来选择并行度、最大线程数以及队列容量等参数。通过合理的配置和监测，可以避免线程池过载或资源浪费，提高应用程序的性能和效率。


# 字节序
https://www.ruanyifeng.com/blog/2016/11/byte-order.html
* 大端序：高位字节存储在地址的低位
* 小端序：高位字节存储在地址的高位

* 32位整数的求值公式
```
/* 大端字节序 */
i = (data[3]<<0) | (data[2]<<8) | (data[1]<<16) | (data[0]<<24);

/* 小端字节序 */
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
```

## 在不同的场景下，使用大端序或小端序可能有不同的原因和考虑因素。下面是几个常见的场景和相应的原因：

处理器架构：某些处理器架构天生支持大端序或小端序。例如，PowerPC 和 Motorola 68k 处理器使用大端序，而 x86 和 ARM 处理器使用小端序。在这种情况下，选择大端序或小端序是为了与特定的处理器架构保持兼容。

网络通信：在网络通信中，数据包往往要在不同的主机和操作系统之间传输。为了确保数据的正确解释，网络协议通常规定使用特定的字节序。例如，TCP/IP 协议规定使用大端序进行数字类型的数据传输。因此，在网络通信中使用大端序可以简化数据转换和协议实现。

存储和持久化：将数据存储到磁盘或其他持久化媒体时，可能需要考虑平台的字节序。如果数据是以固定字节序存储的，那么可以在不同平台上简单地读取和解释这些数据。这在数据共享、数据备份和跨平台开发中非常有用。

数据格式标准：某些数据格式标准（如文件格式、图像格式、音频格式等）可能要求使用特定的字节序。这是为了确保跨平台兼容性和正确解析数据。开发者需要遵循相应的标准规范，以便正确地存储和解释这些数据。

总之，选择大端序或小端序取决于具体的场景需求、处理器架构、网络协议和数据格式标准等因素。在实际开发中，了解所使用的系统和平台的字节序规则，并根据需要进行正确的转换和处理，是确保数据一致性和可移植性的关键。

# c++网络编程中，如何对弱网进行优化
在 C++ 网络编程中，你可以采取以下方法对弱网络进行优化：
* 超时设置：为网络操作设置适当的超时时间。如果网络连接或操作超过设定的超时时间仍未完成，可以中断操作或进行错误处理。这样可以避免长时间等待导致程序阻塞。
* 进行并发操作：使用多线程或异步操作来并发处理多个网络请求。这样可以减少网络请求之间的等待时间，提高网络传输效率。
* 使用非阻塞IO或事件驱动模式：将网络套接字设置为非阻塞模式，并使用 select、poll、epoll 等异步 IO 或事件驱动模型进行网络操作。这样可以实现异步处理，提高网络响应速度。
* 减小数据传输量：优化数据传输的大小，可以通过压缩、协议优化等方式减小数据的传输量。例如，使用压缩算法对数据进行压缩，在网络上传输较小的数据包，从而提高传输效率。
* 断点续传机制：对于大文件或大数据量的网络传输，可以实现断点续传机制，即在网络中断后能够从断点处继续传输，而不必重新传输整个文件或数据。
* 优化网络协议：针对具体的网络场景，可以优化网络协议以适应弱网环境。例如，使用 TCP 协议的带宽自适应算法、拥塞控制等机制来减少网络丢包和重传。
* 数据缓存：在弱网络环境下，可以使用缓存技术对数据进行临时存储，等待网络恢复后再进行传输。这样可以提高用户体验，减少网络传输中断对程序的影响。
* 错误处理与重试机制：对于网络操作的错误，要进行合理的错误处理，并实现重试机制。当网络连接失败或操作超时时，可以尝试重新连接或重复操作，直到成功为止。

通过以上优化方法，你可以使 C++ 网络应用程序在弱网络环境中具有更好的性能和可靠性，提高用户体验和程序的稳定性。根据具体的需求和场景，选择适合的优化策略进行应用。

# 对于一个c++视频服务端，如果对弱网条件下进行优化
对于一个 C++ 视频服务端，在弱网络条件下进行优化的一些方法包括：

* 压缩和优化视频传输：使用压缩算法对视频数据进行压缩，以减小视频数据的传输量。例如，可以使用视频编码标准（如 H.264）对视频进行压缩，并在传输过程中使用流式传输以逐渐播放视频。
* 自适应码率调整：针对弱网条件，实现自适应码率调整机制，根据当前网络状况动态选择合适的视频码率。这样可以在网络带宽不稳定或较低的情况下保持视频播放的流畅性。
* 预加载和缓存：在弱网络条件下，预加载视频数据并缓存一部分视频内容。这样可以通过提前加载视频数据和缓存来减少对网络的依赖，提高用户体验。
* 错误处理和重传机制：对于视频数据的传输错误，实现错误处理和重传机制。当网络条件差或丢包时，及时发起重传请求，确保视频数据的完整性和准确性。
* 流控制和拥塞控制：实现流控制和拥塞控制机制，根据网络状况调整视频数据的传输速率，防止网络拥塞和丢包情况的发生。
* 缓冲区管理：通过合理管理接收和发送缓冲区，确保视频数据的流畅传输。在网络环境差的情况下，增加接收缓冲区的大小，以减少丢包的可能性。
* 优化网络连接和握手过程：通过优化服务器端的网络连接和握手过程，减少握手时间和建立连接所需的网络开销，提高网络响应速度。
* 实时监测和统计：监测网络条件和视频传输的性能指标，例如延迟、丢包率等，进行实时统计和监控。根据统计结果调整优化策略，以适应不同的弱网络条件。

通过以上优化方法，你可以提高 C++ 视频服务端在弱网络条件下的稳定性和性能，保证视频的流畅播放和用户体验。需要根据具体的应用场景和需求选择适当的优化策略，并进行测试和调优，以获得最佳效果。

# 什么是弱网抖动策略
弱网抖动策略是一种针对弱网络条件下的抖动（即网络延迟的变化幅度较大）进行应对的优化策略。在弱网环境中，网络延迟可能会频繁变化，导致数据传输的不可预测性和不稳定性。
* 弱网抖动策略旨在减少因网络抖动引起的问题，以提高网络传输的效果和可靠性。以下是几种常见的弱网抖动策略：
* 缓冲区管理：通过增加接收缓冲区的大小来处理网络抖动。当网络延迟增加时，较大的接收缓冲区可以缓冲更多的数据，以避免数据丢失或应用程序阻塞。
* 抖动缓冲：引入抖动缓冲来平滑网络延迟的变化。抖动缓冲会暂时存储接收到的数据，在网络抖动较大时提供一个平滑的数据流输出。
* 重传和丢包处理：当发生数据包丢失时，采取相应的重传机制来确保数据的完整性。例如，使用重传请求或前向错误纠正等技术来纠正由网络抖动引起的数据丢失。
* 自适应码率调整：根据网络抖动情况动态调整视频或音频的传输码率。通过降低码率可以减少对网络带宽的需求，以适应网络延迟的变化。
* 流控制和拥塞控制：采用流控制和拥塞控制算法来平衡数据发送和接收之间的速度，以避免网络抖动导致的拥塞和丢包现象。
* 错误纠正和冗余机制：引入冗余数据和错误纠正技术来应对网络抖动带来的数据丢失和损坏。这些机制可以提供更高的数据可靠性，确保数据的正确传输。

通过采用弱网抖动策略，可以有效应对弱网络环境下的抖动问题，提高网络传输的稳定性和可靠性。具体的策略选择和实施方式需要根据应用场景和需求来确定，并进行测试和调优以获得最佳效果。


# c++网络编程如何设计错误纠正和冗余机制
在 C++ 网络编程中，设计错误纠正和冗余机制需要考虑数据包的发送、接收和检验过程。以下是一种常见的实现方法，以数据校验和作为示例：

1. 发送端设计：
    * 在发送端，将要发送的数据按照一定的规则进行划分，并计算数据校验和。
    * 在数据包中添加一个校验和字段，用于存储计算得到的校验和。
    * 将数据包发送给接收端。
2. 接收端设计：
    * 在接收端，接收到数据包后，提取数据和校验和字段。
    * 对接收到的数据重新计算校验和值。
    * 将计算得到的校验和与接收到的校验和进行比较。
    * 如果两个校验和相同，则说明数据包没有错误，可以继续处理该数据。
    * 如果校验和不匹配，则说明数据包可能存在错误。
4. 错误处理和重传：
    * 如果发现数据包的校验和不匹配，可以触发错误处理和重传机制。
    * 发送端可以通过接收到的确认或反馈信息来确定需要重新发送的数据包，并进行重传操作。
    * 接收端在接收到重传的数据包后，再次进行校验和比较，直到校验和匹配为止。
5. 冗余机制：
    * 为了增加数据的冗余性，可以引入冗余数据来应对网络错误。
    * 发送端可以在每个数据包中添加冗余数据，例如通过重复发送相同的数据或添加冗余校验码等。
    * 接收端接收到多个冗余数据时，可以进行冗余校验操作，以保证数据的完整性和正确性。

需要注意的是，以上是一种简单的示例，实际实现错误纠正和冗余机制可能需要根据具体情况进行调整。例如，可以使用更强大的差错检测和纠正算法（如循环冗余校验码 CRC），或者结合其他技术和协议（如前向纠错编码 FEC）来提高数据的可靠性和容错性。

此外，在设计错误纠正和冗余机制时，还应考虑网络延迟、带宽和系统资源等因素，以平衡数据传输的效率和可靠性。


# 请模拟一次高级c++网络工程师面试
当然，我可以模拟一次高级 C++ 网络工程师的面试。以下是一些常见的问题，你可以回答并提供你的解决方案。

1. 请解释 TCP 和 UDP 的区别，并提供适用场景。

答：TCP（传输控制协议）和 UDP（用户数据报协议）都是在网络通信中常用的传输层协议。主要区别如下：

* TCP 是面向连接的，提供可靠的、有序的、基于字节流的通信；UDP 是无连接的，不保证数据的可靠性和顺序性。
* TCP 提供错误检测、重传机制和流量控制；UDP 不提供这些机制，仅提供最小的错误检测功能。
* TCP 的开销较大，因为需要建立和维护连接状态；UDP 的开销较小，因为无需建立连接。

适用场景：

* TCP 适用于对数据可靠性要求高、顺序要求严格的应用，如文件传输、电子邮件等。
* UDP 适用于实时性要求高、数据丢失可容忍的应用，如音视频传输、实时游戏等。

2. 解释 TCP 的三次握手过程。

答：TCP 的三次握手过程用于在发送端和接收端之间建立可靠的连接。具体步骤如下：

* 第一次握手：发送端向接收端发送一个 SYN（同步）报文段，指示发送端请求建立连接。
* 第二次握手：接收端收到 SYN 报文段后，会发送一个 ACK（确认）报文段作为响应，并发送一个自己的 SYN 报文段。
* 第三次握手：发送端收到接收端的 ACK 报文段和 SYN 报文段后，会发送一个 ACK 报文段作为最后的确认。

随着三次握手的完成，连接的双方都知道彼此已准备好进行通信。这种握手过程确保了双方都能在连接建立之前进行同步和确认，从而确保连接的可靠性和完整性。

3. 你如何处理网络中的粘包问题？

答：网络中的粘包问题可以通过以下方法来处理：

* 使用固定长度的消息：发送端将数据分割成固定大小的消息，在接收端按照相同大小的缓冲区接收和处理。
* 使用特殊字符进行分隔：在每个消息的末尾添加一个特殊字符（如换行符或空格），接收端根据特殊字符将消息分割开。
* 使用消息长度字段：在消息的头部添加一个表示消息长度的字段，接收端先读取长度字段，然后根据长度读取相应大小的数据。

这些方法都需要发送端和接收端遵循相同的消息分割规则，以确保准确地分割和处理消息，从而解决粘包问题。

4. 如何实现长连接？

答：实现长连接可以使用以下方法：

* 保持连接打开状态：在发送和接收数据之后，保持 TCP 或 UDP 连接处于打开状态，以便后续的数据交换。
* 心跳机制：定时向对方发送特定的心跳消息，以确认连接的有效性。如果一段时间内未收到心跳响应，则断开连接。
* 断线重连：当连接断开时，可以尝试重新连接服务器，并恢复之前的会话状态。

注意：长连接可能会占用服务器资源，因此需要在设计时考虑到连接的管理和资源消耗。

这些问题只是面试中的一小部分，希望对你进行模拟面试有所帮助。请根据你的实际经验和知识回答这些问题，并展示你在 C++ 网络编程方面的专业知识。祝你好运！

# 既然getsockopt可以检测tcp连接是否断开，为什么还需要设计心跳包
确实，可以使用getsockopt函数的SO_ERROR选项来检测TCP连接是否断开。该方法可以通过查询套接字状态来确定连接状态，但它只提供一次快速的连接状态检查，不能实时地监测连接是否保持活跃。

设计心跳包的原因主要有以下几点：

1. 实时性：getsockopt只提供了一次连接状态的检查，而心跳包可以通过定期发送并等待对方回复来实时监测连接的存活状态。通过设置适当的心跳间隔，可以更及时地发现连接中断或异常情况。
2. 网络设备限制：某些网络设备（如防火墙或代理服务器）可能会过滤或丢弃某些特定类型的数据包，导致对于getsockopt来说，连接看起来仍然是有效的，但实际上已经无法正常通信。发送心跳包可以绕过这些限制，确保连接的可靠性。
3. 应用层控制：心跳包是在应用层上实现的，可以根据具体应用的需求和场景进行灵活的设计。例如，可以自定义心跳包的格式和内容，以便在心跳包中携带一些业务相关的信息，进一步验证对方节点的可用性或状态。
4. 报文交互：心跳包通常是双向的，需要对方节点接收并回复。通过心跳包的交互，可以确保连接的双向通信的正常性，而不仅是简单地检查连接状态。

总的来说，尽管可以使用getsockopt函数来检测TCP连接的状态，但设计心跳包可以提供更实时、可靠和灵活的连接监测和维护。它可以应对一些特殊情况下的网络限制，并允许应用层控制和自定义。

# 心跳包机制
https://zhuanlan.zhihu.com/p/626960589
* 长时间没有数据往来，可能会被防火墙程序关闭连接
* 连接链路中的关键路由器或者交换机故障，无法及时感知到连接是否正常，即“死链”问题

- 心跳包可用来保活以及检测死链（及时关闭socket，回收连接资源）
- 一般客户端应主动给服务端端发送心跳包，服务端应答心跳包
- 心跳包也可以携带一些业务数据
- 心跳包间隔可按需设置15s-45s不等

## TCP keepalive 选项
```
//on 是 1 表示打开 keepalive 选项，为 0 表示关闭，0 是默认值
int on = 1;
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on))

//发送 keepalive 报文的时间间隔
int val = 7200;
setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val));

//两次重试报文的时间间隔
int interval = 75;
setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(interval));

// 如果重试 9 次（TCP_KEEPCNT 值）（前后重试间隔为 75 秒（TCP_KEEPINTVL 值））仍然不可达，则向应用程序返回 ETIMEOUT（无任何应答）或 EHOST 错误信息。
int cnt = 9;
setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));
```


# addrinfo
```
struct addrinfo {
    int ai_flags;           // 地址标志
    int ai_family;          // 地址族
    int ai_socktype;        // 套接字类型
    int ai_protocol;        // 协议
    socklen_t ai_addrlen;   // 地址长度
    struct sockaddr* ai_addr;  // 地址数据结构
    char* ai_canonname;     // 规范主机名
    struct addrinfo* ai_next;   // 指向下一个结果的指针
};
```
* ai_flags指定了一些地址获取的选项标志，如AI_PASSIVE表示适用于服务器端。
* ai_family指定了地址族（Address Family），例如AF_INET表示IPv4，AF_INET6表示IPv6。
* ai_socktype指定了套接字类型（Socket Type），如SOCK_STREAM表示流式套接字。
* ai_protocol指定了套接字使用的协议（Protocol），如IPPROTO_TCP表示TCP协议。
* ai_addrlen是地址长度（Address Length）。
* ai_addr指向sockaddr结构体的指针，包含了实际的地址信息。
* ai_canonname是规范主机名（Canonical Host Name），即主机名的规范格式。
* ai_next是一个指向下一个addrinfo结构体的指针，用于遍历多个结果。

ai_flags（地址标志）：
    取值范围：可以使用零或以下标志的按位或组合：
        AI_PASSIVE：适用于服务器端，表示用于监听连接的地址。
        AI_CANONNAME：返回一个规范主机名。
    含义：指定地址获取的选项标志。

ai_family（地址族）：
    取值范围：
        AF_UNSPEC：不限定地址族，允许IPv4或IPv6。
        AF_INET：IPv4地址族。
        AF_INET6：IPv6地址族。
    含义：指定地址族类型。

ai_socktype（套接字类型）：
    取值范围：
        SOCK_STREAM：流式套接字，提供可靠的、面向连接的通信。
        SOCK_DGRAM：数据报套接字，提供不可靠的、无连接的通信。
        SOCK_RAW：原始套接字，提供对网络层以上协议的直接访问。
    含义：指定套接字类型。

ai_protocol（协议）：
    取值范围：根据套接字类型的不同，可以使用协议号常量（如IPPROTO_TCP、IPPROTO_UDP）或设置为零表示默认协议。
    含义：指定套接字使用的协议。

ai_addrlen（地址长度）：
    取值范围：某个特定平台上地址结构体的大小。
    含义：指定地址长度。

ai_addr（地址数据结构）：
    取值范围：指向一个sockaddr结构体的指针，其中存储了实际的地址信息。
    含义：指定地址信息。

ai_canonname（规范主机名）：
    取值范围：字符串指针，可能为NULL。
    含义：返回规范化的主机名。

ai_next（下一个结果）：
    取值范围：指向下一个addrinfo结构体的指针，可能为NULL。
    含义：用于遍历多个解析结果，形成链表。


# struct sockaddr
```
struct sockaddr {
    sa_family_t sa_family;  // 地址族，用于指定地址的类型
    char sa_data[14];       // 地址数据，具体内容与地址族相关
};
```

sa_family：
    类型：sa_family_t
    取值范围：根据地址族的不同而变化，常见的取值有 AF_INET（IPv4）、AF_INET6（IPv6）和 AF_UNIX（Unix 域）
    含义：用于指定地址的类型或族，决定了 sa_data 字段中存储的具体地址数据的形式。

sa_data：
    类型：char[14]
    取值范围：具体内容与地址族相关，不同的地址族可能会使用不同的数据结构存储地址信息。
    含义：存储地址的实际数据，其格式和含义取决于地址族类型。例如，在 IPv4 地址族中，前4个字节存储 IP 地址，后2个字节存储端口号。

需要注意的是，struct sockaddr 是一个通用的结构体，在实际编程中，可能会使用它的具体派生类型来表示特定类型的地址，如 struct sockaddr_in 用于表示 IPv4 地址，struct sockaddr_in6 用于表示 IPv6 地址，struct sockaddr_un 用于表示 Unix 域地址等。这些派生类型在具体应用场景中定义了更多的字段，以便存储相应地址族的具体信息。

## struct sockaddr_in
```
struct sockaddr_in {
    sa_family_t     sin_family; // 地址族，通常为 AF_INET（IPv4）
    in_port_t       sin_port;   // 16 位端口号
    struct in_addr  sin_addr;   // 32 位 IP 地址
    char            sin_zero[8]; // 填充字段，通常设置为全 0
};
```

sin_family 字段：
    取值范围：AF_INET（IPv4 地址族）。
    含义：指定地址族类型，用于确定 sockaddr_in 结构体的具体含义。
sin_port 字段：
    取值范围：0~65535。
    含义：表示 IPv4 地址中的 16 位端口号。
sin_addr 字段：
    类型：struct in_addr
    取值范围：32 位无符号整数。
    含义：表示 IPv4 地址中的 32 位 IP 地址。
sin_zero 字段：
    类型：char[8]
    取值范围：没有特殊限制。
    含义：用于填充字段，通常设置为全 0。

## struct sockaddr_in6
```
struct sockaddr_in6 {
    sa_family_t     sin6_family;   // 地址族，通常为 AF_INET6（IPv6）
    in_port_t       sin6_port;     // 16 位端口号
    uint32_t        sin6_flowinfo; // 流信息
    struct in6_addr sin6_addr;     // 128 位 IPv6 地址
    uint32_t        sin6_scope_id; // 作用域 ID
};
```

sin6_family 字段：
    取值范围：AF_INET6（IPv6 地址族）。
    含义：指定地址族类型，用于确定 sockaddr_in6 结构体的具体含义。
sin6_port 字段：
    取值范围：0~65535。
    含义：表示 IPv6 地址中的 16 位端口号。
sin6_flowinfo 字段：
    取值范围：32 位无符号整数。
    含义：用于流控制和服务质量(QoS)相关的标识。
sin6_addr 字段：
    类型：struct in6_addr
    取值范围：128 位二进制数，表示 IPv6 地址。
    含义：表示 IPv6 地址中的 128 位 IP 地址。
sin6_scope_id 字段：
    取值范围：32 位无符号整数。
    含义：用于指定接口的作用域 ID，通常在连接到链接本地地址时使用。

## struct sockaddr_un
```
struct sockaddr_un {
    sa_family_t sun_family; // 地址族，通常为 AF_UNIX（Unix 域）
    char        sun_path[108]; // 文件路径名
};
```

sun_family 字段：
    取值范围：AF_UNIX（Unix 域地址族）。
    含义：指定地址族类型，用于确定 sockaddr_un 结构体的具体含义。
sun_path 字段：
    类型：char[108]
    取值范围：没有特殊限制。
    含义：表示 Unix 域套接字对应文件的路径名。
