# C++高性能网络编程
https://huangwang.github.io/2019/10/26/CPlusPlus%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/


# *Skynet 设计综述
https://blog.codingnow.com/2012/09/the_design_of_skynet.html

# *Epoll原理解析
https://blog.csdn.net/armlinuxww/article/details/92803381
* 进程阻塞不占用CPU资源
* recv/select/epoll都是阻塞方法
* 进程创建socket的时候，操作系统会创建一个由文件系统创建的socket对象
* socket对象包含发送缓冲区/接收缓冲区以及等待队列等成员

# 我们说 TCP 是流式协议究竟意味着什么？
https://cloud.tencent.com/developer/article/1848087
* 如果是 TCP 协议，在大多数场景下，是不存在丢包和包乱序问题的，TCP 通信是可靠通信方式，TCP 协议栈通过序列号和包重传确认机制保证数据包的有序和一定被正确发到目的地；如果是 UDP 协议，如果不能接受少量丢包，那就要自己在 UDP 的基础上实现类似 TCP 这种有序和可靠传输机制了（例如 RTP 协议、RUDP 协议）

* 先来解释一下什么是粘包，所谓粘包就是连续给对端发送两个或者两个以上的数据包，对端在一次收取中收到的数据包数量可能大于 1 个，当大于 1 个时，可能是几个（包括一个）包加上某个包的部分，或者干脆就是几个完整的包在一起。当然，也可能收到的数据只是一个包的部分，这种情况一般也叫半包。

## 如何区分呢？一般有三种分包方法：
* 固定包长的数据包
* 以指定字符（串）为包的结束标志
* 包头 + 包体格式

# TCP/IP协议中，数据包丢失指的是部分丢失还是全部丢失
在TCP/IP协议中，数据包丢失指的是全部丢失而非部分丢失。当数据包从源主机发送到目的主机时，它将沿途经过许多路由器和交换机等设备，如果发生了数据包丢失，这意味着整个数据包被丢失，没有任何一部分到达了目的地。

TCP协议通过重传丢失的数据包来确保数据的完整性和可靠性。当发送方在收到确认消息之前没有收到对应的ACK消息时，它会假定数据包可能已经丢失，并向目标重新发送该数据包。这个过程将持续一段时间，直到发送方收到确认消息为止。如果确认消息没有及时到达，数据包将被再次发送，如果多次尝试后仍然无法成功，TCP协议将在超时后放弃该连接。

总的来说，TCP协议被设计为具有可靠的数据传输功能，即使数据包在传输过程中丢失也会进行重传，以确保数据的完整性。因此，在TCP/IP协议中，数据包丢失指的是数据包全部丢失的情况。

# TCP/IP协议中，数据包有可能出现部分数据位错误的问题吗
在TCP/IP协议中，数据包的出错指的是数据包在传输过程中的比特位错误。这种比特位错误可能会导致部分数据位的错误或损坏。

TCP协议通过校验和（Checksum）机制来检测传输过程中的数据损坏。发送端在发送数据包之前，会计算校验和，并将其添加到数据包中。接收端在接收到数据包后，也会计算校验和，然后将结果与传输过来的校验和进行比较。如果两者不一致，就说明数据包在传输过程中发生了错误。

当数据包的比特位在传输过程中损坏时，校验和机制可以帮助检测到这些错误。一旦校验和不匹配，接收端会丢弃该数据包，并请求发送端重新发送数据。这样可以确保数据的准确性。

虽然校验和机制可以检测到大部分的数据损坏问题，但并不能解决所有可能的错误情况。例如，如果在校验和计算之前，数据包已经被其他网络设备修改或篡改，那么校验和机制就可能无法识别错误。

因此，尽管TCP/IP协议通过校验和机制来检测数据包的错误，但仍存在一定的概率出现部分数据位错误的情况，尤其是在面对恶意攻击或网络故障等复杂环境下。

# TCP/IP协议如何保证可靠传输的
TCP/IP协议是一种可靠的传输协议，通过以下机制来保证数据的可靠传输：

1. 序号和确认机制：TCP协议采用序号和确认机制来确保数据包的有序传输。每个TCP数据包都有一个序列号（Sequence Number），接收端按照序列号将数据包进行重组，确保数据正确地按照顺序重新组装。接收端在成功接收到一个TCP数据包后，会向发送端发送一个确认消息（Acknowledgment，ACK），确认接收到该数据包。发送端接收到确认消息后，就知道数据包已经安全到达目的地。

2. 超时重传机制：如果数据包在传输过程中发生丢失或延迟，接收端会等待一段时间来接收数据包，如果超过一定时间仍未收到相关数据包，则会触发超时重传机制，要求发送端重新发送丢失的数据包。

3. 滑动窗口机制：TCP协议使用滑动窗口机制来管理发送方和接收方之间的数据传输。发送方在发送数据包时，会根据接收方返回的确认消息来确定可以发送多少数据包，接收方利用滑动窗口的大小来控制发送方的发送速率。

4. 校验和机制：TCP协议通过校验和机制来检测传输过程中的数据损坏。发送端在发送数据包之前，会计算校验和，并将其添加到数据包中。接收端在接收到数据包后，也会计算校验和，然后将结果与传输过来的校验和进行比较。如果两者不一致，就说明数据包在传输过程中发生了错误。

综上所述，TCP/IP协议通过序号和确认机制、超时重传机制、滑动窗口机制、校验和机制等多种技术手段来保证数据的可靠传输。这些机制可以有效地应对各种常见的网络问题，确保数据的安全性和可靠性。

# 请介绍一下TCP ip四层协议，并说明每一层数据包的结构
TCP/IP协议是互联网通信的基础协议之一，它由四个层次组成：网络接口层、网络层、运输层和应用* 层。每个层次都有特定的功能和对应的数据包结构。

1. 网络接口层（Network Interface Layer）：
   - 功能：负责将数据帧从物理网络传输到连接的网络设备上。
   - 数据包结构：对于以太网，数据包结构包括目标MAC地址、源MAC地址和有效数据。

2. 网络层（Internet Layer）：
   - 功能：负责将数据包从源主机传输到目标主机，通过IP地址实现寻址和路由选择。
   - 数据包结构：IP数据报结构包括版本、首部长度、服务类型、总长度、标识、标志、分片偏移、生存时间、协议、首部校验和、源IP地址、目标IP地址和数据。

3. 运输层（Transport Layer）：
   - 功能：为应用程序提供端到端的通信服务，包括可靠性传输和数据流控制。
   - 数据包结构：
     - TCP（传输控制协议）：TCP数据包结构包括源端口号、目标端口号、序列号、确认号、首部长度、标志位、窗口大小、检验和、紧急指针和数据。
     - UDP（用户数据报协议）：UDP数据包结构包括源端口号、目标端口号、长度、检验和和数据。

4. 应用层（Application Layer）：
   - 功能：定义了各种应用程序使用的协议和服务，如HTTP、FTP、SMTP等。
   - 数据包结构：具体的数据包结构取决于应用层协议，例如HTTP数据包结构包括请求行、首部、主体等。

这四个层次相互关联，每一层将上一层提供的数据打包成特定的数据包结构，并交给下一层进行处理。通过分层的方式，TCP/IP协议可以实现灵活的网络通信和扩展性。在实际的数据传输中，数据会从应用层逐层封装，在接收端则会逐层解封装，以完成数据的传输和处理。

# 请介绍一下TCP/IP四层协议，并用ascii图的形式描述一下每一层数据包的结构
TCP/IP协议是互联网通信的基础协议之一，它由四个层次组成：应用层、传输层、网络层和数据链路层。下面是每一层数据包结构的简单描述：

```
   +-----------------------------------------------------+
   |                   应用层 (Application Layer)                 |
   +-----------------------------------------------------+
   |                       应用数据                          |
   +-----------------------------------------------------+

   +-----------------------------------------------------+
   |                    传输层 (Transport Layer)                    |
   +-----------------------------------------------------+
   |           源端口号        |        目标端口号          |
   +-----------------------------------------------------+
   |                      校验和                           |
   +-----------------------------------------------------+
   |                      应用数据                          |
   +-----------------------------------------------------+

   +-----------------------------------------------------+
   |                     网络层 (Network Layer)                    |
   +-----------------------------------------------------+
   |              源IP地址                  |              目标IP地址             |
   +-----------------------------------------------------+
   |                     标识                         |              标记位            |
   +-----------------------------------------------------+
   |                      生存时间                        |              协议            |
   +-----------------------------------------------------+
   |                     校验和                         |
   +-----------------------------------------------------+
   |                      应用数据                          |
   +-----------------------------------------------------+

   +-----------------------------------------------------+
   |                  数据链路层 (Data Link Layer)                |
   +-----------------------------------------------------+
   |      目标MAC地址       |        源MAC地址         |
   +-----------------------------------------------------+
   |              类型/长度              |
   +-----------------------------------------------------+
   |                      应用数据                          |
   +-----------------------------------------------------+
```

以上是每一层数据包结构的简单描述，每个层次的数据包都有特定的字段和用途。具体的数据包结构可能会根据具体的协议和需求而有所不同。这个简单的ASCII图只是为了帮助理解，并不能完整地表示协议的复杂性和详细规范。
# 使用C++11原子量实现自旋锁
https://www.cnblogs.com/FateTHarlaown/p/9170474.html
```
#include <atomic>

class SpinLock {

public:
    SpinLock() : flag_(false)
    {}

    void lock()
    {
        bool expect = false;
        while (!flag_.compare_exchange_weak(expect, true))
        {
            //这里一定要将expect复原，执行失败时expect结果是未定的
            expect = false;
        }
    }

    void unlock()
    {
        flag_.store(false);
    }

private:
    std::atomic<bool> flag_;
};

```

# 请介绍一下c++中的自旋锁
自旋锁（Spinlock）是一种基于忙等待的同步机制，用于实现临界区互斥访问，主要用于多线程编程中。在 C++ 中，标准库中并没有提供自旋锁的实现，但可以使用操作系统提供的原子操作等底层库来实现自旋锁。

自旋锁与互斥锁类似，它也有两个状态：已锁定和未锁定。当一个线程请求对一个自旋锁进行加锁时，如果该自旋锁处于未锁定状态，那么该线程就将它锁定，并进入临界区，执行相应操作。如果该自旋锁已经被其他线程锁定，那么当前线程将循环检测该自旋锁是否变为未锁定状态，在此期间不会被挂起，而是一直占用 CPU 时间进行循环等待。当该自旋锁变为未锁定状态时，该线程将立即将其锁定，并进入临界区。

下面是一个简单的使用 C++11 原子类型 `std::atomic_flag` 实现的自旋锁示例：

```cpp
#include <atomic>

class Spinlock {
public:
    Spinlock(): flag(ATOMIC_FLAG_INIT) {}

    void lock() {
        while (flag.test_and_set(std::memory_order_acquire));
    }

    void unlock() {
        flag.clear(std::memory_order_release);
    }

private:
    std::atomic_flag flag;
};
```

在上面的代码中，`lock()` 和 `unlock()` 分别用于加锁和解锁操作。其中，`std::atomic_flag` 是一个基于原子操作的布尔类型，包含了以下两个原子操作方法：

- `test_and_set(std::memory_order order)`: 原子地将 `flag` 设为 `true`，并返回原来的值。使用指定的内存序 `order`。
- `clear(std::memory_order order)`: 原子地将 `flag` 设为 `false`。使用指定的内存序 `order`。

在 `lock()` 中，使用 `while` 循环检测自旋锁状态。如果当前自旋锁已经被其他线程锁定，那么 `test_and_set()` 方法返回 `true`，循环继续；否则，将自旋锁设为锁定状态，并且跳出循环，进入临界区。在 `unlock()` 中，使用 `clear()` 方法将自旋锁设为未锁定状态。

需要注意的是，自旋等待期间会一直占用 CPU 资源，因此自旋锁适用于临界区锁定时间较短的场景。当临界区锁定时间较长时，使用互斥锁等其他同步机制可能更加适合。


# 什么情况下必须使用自旋锁
使用自旋锁的情况通常包括以下几个方面：

1. 临界区锁定时间短：自旋锁适用于临界区锁定时间较短的情况，即临界区内的代码执行时间很短。如果临界区的代码执行时间长，那么其他线程在等待期间会一直占用 CPU 资源，导致性能下降。

2. 线程阻塞代价高：自旋锁适用于线程阻塞代价高的情况。当一个线程请求一个已经被其他线程锁定的自旋锁时，它会一直循环等待而不是被挂起。相比于线程上下文切换的开销，自旋等待的开销较小。因此，在线程阻塞/唤醒的代价较高的情况下，自旋锁可以提供更好的性能。

3. 多核处理器：自旋锁适用于多核处理器的情况。在多核处理器中，多个线程可以并行执行。当一个线程请求一个已经被其他线程锁定的自旋锁时，该线程可以继续执行其他计算任务，而不是被挂起等待。这样可以让 CPU 内核充分利用多核并行处理的优势，提高整体性能。

需要注意的是，自旋锁并不适用于所有情况。在以下情况下，使用自旋锁可能会导致性能下降：

1. 临界区锁定时间长：如果临界区的代码执行时间长，其他线程在等待期间会一直占用 CPU 资源，导致性能下降。这种情况下，应该考虑使用互斥锁等其他同步机制。

2. 单核处理器：在单核处理器中，只能顺序执行线程，并没有并行执行的能力。自旋锁会导致当前线程一直循环等待，浪费大量的 CPU 时间。这种情况下，应该使用互斥锁等会挂起当前线程的同步机制。

综上所述，在临界区锁定时间短、线程阻塞代价高、多核处理器等情况下，选择使用自旋锁可以提供较好的性能。在其他情况下，应该根据实际需求选择合适的同步机制。

# 如何写出高质量的代码
写出高质量的代码是每个程序员追求的目标。下面是一些提升代码质量的建议：

1. 遵循编码规范：选择一种统一的编码规范（如Google编码风格），并确保团队内所有成员都遵循。这有助于代码的可读性和易于维护。

2. 使用有意义的命名：使用清晰、准确的变量、函数和类名，避免使用缩写或单字符命名。这样可以提高代码的可读性，并且让其他人更容易理解你的代码意图。

3. 单一职责原则：每个函数、类或模块应该只负责一项具体的任务。这样可以提高代码的模块化程度，使其易于测试和重用。

4. 避免冗余代码：删除重复的代码，使用函数、循环和继承等技术来避免冗余。这不仅提高了可读性，还减少了代码维护的工作量。

5. 注释清晰明确：在关键位置添加注释，解释代码的意图和实现思路。好的注释能够帮助他人更好地理解你的代码。

6. 异常处理：合理处理异常，避免空指针异常和其他常见的运行时错误。使用try-catch语句来捕获异常，并提供有意义的错误信息。

7. 单元测试：编写单元测试用例，覆盖尽可能多的代码路径和边界条件。这样可以确保代码在不同情况下的正确性，并方便进行重构和调试。

8. 代码复审：通过代码审查来发现潜在的问题、bug或概念上的错误。多人合作可以帮助发现代码中的问题，并提出改进意见。

9. 持续集成和持续交付：使用工具自动化构建、测试和部署过程，确保代码的稳定性和可靠性。

10. 学习和不断改进：保持学习态度，关注新技术和最佳实践。参与开源项目、阅读优秀的代码和技术文章，以不断提升自己的编码水平。

以上是一些常见的提高代码质量的方法，当然还有其他因素如设计模式、性能优化等可以进一步深入研究和实践。

# 有没有什么工具可以协助保证高质量的代码
是的，有很多工具可以协助保证高质量的代码。下面是一些常用的工具：

1. 静态代码分析工具：例如Pylint（Python）、Checkstyle（Java）、ESLint（JavaScript）等，可以检查代码是否符合编码规范，并提供改进建议。

2. 单元测试框架：例如JUnit（Java）、Pytest（Python）、Mocha（JavaScript）等，可以编写和运行单元测试用例，验证代码的正确性。

3. 持续集成工具：如Jenkins、Travis CI、CircleCI等，可以自动化构建、测试和部署过程，确保代码在不同环境下的稳定性和可靠性。

4. 代码覆盖率工具：例如Jacoco（Java）、Coverage.py（Python）、Istanbul（JavaScript）等，可以测量代码的测试覆盖率，帮助发现测试不足的区域。

5. 可视化工具：例如SonarQube、CodeClimate等，可以生成代码质量报告，包括代码复杂度、重复代码、潜在bug等指标。

6. 版本控制系统：如Git、SVN等，可以追踪代码变更、进行代码审查、管理分支等，以保证团队协作和代码质量。

7. 编辑器和集成开发环境（IDE）插件：例如Visual Studio Code、PyCharm、Eclipse等，提供语法高亮、自动补全、代码格式化等功能，帮助编写规范的代码。

这些工具可以根据具体需求和编程语言进行选择和配置，通过结合使用可以提高代码质量，并帮助开发团队更加高效地进行软件开发。同时，还可以根据项目的实际情况，结合团队的经验和需求，选择适合的工具和流程来保障代码质量。

# 有没有什么工具可以协助保证高质量的c++代码
是的，有一些工具可以协助保证高质量的C++代码。以下是一些常用的工具：

1. 静态代码分析工具：例如Clang-Tidy、Cppcheck、PVS-Studio等。它们可以检查代码中的错误、潜在问题、不良实践和代码风格违规，并提供改进建议。

2. 编码规范检查工具：例如Cppcheck、ClangFormat、Uncrustify等。它们可以检查代码是否符合特定的编码规范，并自动修复或格式化代码。

3. 编译器警告：现代C++编译器（如GCC、Clang）提供了丰富的警告选项，可以帮助发现潜在的问题和不良实践。开启适当的警告级别，并解决所有警告，有助于提高代码质量。

4. 单元测试框架：例如Google Test、Catch2、Boost.Test等。单元测试可以验证代码的正确性，并在后续的修改和重构中提供保障。

5. 覆盖率工具：例如gcov、LLVM的Code Coverage等。它们可以测量代码的测试覆盖率，帮助发现未经测试的代码区域，并指导测试用例的编写。

6. 内存泄漏检测工具：例如Valgrind、AddressSanitizer等。它们可以检测代码中的内存泄漏、访问越界等问题，提高代码的健壮性和可靠性。

7. 代码审查工具：例如Phabricator、Gerrit等。它们提供代码审查功能，让团队成员能够检查、评审和讨论代码变更，从而发现潜在的问题并提出改进意见。

这些工具可以帮助发现常见的C++代码问题，并提供改进建议，从而提高代码质量和可维护性。通过结合使用这些工具，并遵循良好的软件工程实践，可以有效地减少错误和缺陷，并促进高质量的C++代码编写。

# 什么是 ARQ Protocol
ARQ全称为Automatic Repeat Request，即自动重传请求。ARQ协议是一种数据链路层的协议，它保证了数据在传输过程中的可靠性。

ARQ协议的工作原理是当接收方接收到损坏的数据帧时，会向发送方发送一个重传请求。发送方接收到重传请求后，会重新发送这个数据帧。如果发送方没有收到接收方的确认，则会继续发送数据帧，直至接收到确认为止。如果达到最大重传次数仍未收到确认，则会放弃该数据帧的传输。

根据ARQ协议的不同实现方式，可以将其分为以下几种类型：

1. 停等协议（Stop-and-Wait ARQ）：发送方每发送一帧数据后就停下来等待接收方的确认，只有收到确认才会继续发送下一帧数据。接收方只能接收到正确的数据帧才能发送确认帧。

2. 回退N帧协议（Go-Back-N ARQ）：发送方可以连续发送多个帧，接收方按照顺序接收并确认。如果某个帧出现错误，则将从该帧开始所有未确认的帧全部丢弃，并要求发送方从该帧开始重传。

3. 选择重传协议（Selective Repeat ARQ）：发送方可以同时发送多个帧，接收方收到帧后存储并等待后续的帧。如果某个帧出现错误，则只需要重传这个帧即可，其他帧不受影响。

ARQ协议是数据链路层中最基本的可靠性协议之一，可以保证数据在传输过程中的可靠性。同时，ARQ协议在实际应用中也有很多的优化方式，例如通过累积确认来减少网络流量，或者通过NACK（Negative Acknowledgment）来减少重传次数等。

# 介绍一下SIGPIPE信号
SIGPIPE信号是一种在Linux和类Unix系统上使用的信号，用于通知进程"管道破裂"或"写入关闭的管道"的事件。当一个进程向一个已经被另一个进程或者自身关闭写入端的管道进行写操作时，内核会向该进程发送SIGPIPE信号。

SIGPIPE信号的默认处理行为是终止进程。因此，在处理网络编程中的数据传输时，我们应该注意避免SIGPIPE信号的产生，或者对其进行适当的处理，以防止进程异常终止。

常见情况下，SIGPIPE信号会在以下几种情况下产生：

1. 写一个已关闭写入端的管道：当一个进程尝试写入一个已经被关闭写入端的管道时，内核会向该进程发送SIGPIPE信号。这通常发生在与客户端连接的socket被客户端意外关闭后，服务端仍然尝试向客户端发送数据时。

2. 向一个没有读取进程的管道写数据：如果写入端向一个没有读取进程的管道写数据，会导致管道填满，并且进程将再次收到SIGPIPE信号。

为了避免进程因为SIGPIPE信号而异常终止，可以采取以下几种处理方法：

- 忽略SIGPIPE信号：可以在程序中使用`signal(SIGPIPE, SIG_IGN)`函数或者`sigaction`函数将SIGPIPE信号的处理方式设置为忽略，这样进程在写入关闭的管道时，不会终止，而是返回一个错误。

- 检查write()函数的返回值：在向文件描述符或socket写入数据时，检查write()函数的返回值。如果返回值为-1，并且errno为EPIPE表示出现了SIGPIPE信号的情况，可以根据具体需求进行相应的处理。

- 处理SIGPIPE信号：可以编写信号处理函数来处理SIGPIPE信号，例如关闭相应的文件描述符或socket，清理资源，记录日志等。

简而言之，SIGPIPE信号是用于通知进程发生管道破裂或写入关闭的管道的事件。在网络编程中，我们应该避免忽略此信号的出发，或者对其进行适当的处理，以确保程序的稳定运行。

# Linux c++ 网络编程中，客户端和服务端如何检测并处理对方主动断开的情况
在 Linux C++ 网络编程中，客户端和服务端都可以通过检测对方的主动断开来处理连接的异常情况。下面是一些常用的方法：

1. 客户端检测对方主动断开：
   - 在客户端的代码中，可以使用 `recv()` 或 `read()` 等函数进行数据接收操作，如果返回值为 0，表示服务端已经关闭了连接，即主动断开。
   - 此时，客户端可以关闭套接字，并进行相应的处理，例如清理资源、发送日志等。

2. 服务端检测对方主动断开：
   - 在服务端的代码中，可以使用 `recv()` 或 `read()` 等函数进行数据接收操作，如果返回值为 0，表示客户端已经关闭了连接，即主动断开。
   - 此时，服务端可以关闭与该客户端相关的套接字，停止服务线程或者进行其他适当的处理。

另外，为了更好地处理对方主动断开的情况，也可以结合使用信号处理机制。例如，在客户端或服务端中可以注册并处理 SIGPIPE 信号，以便在出现对方主动断开时及时收到信号并进行相应的处理。示例代码如下：

```cpp
#include <iostream>
#include <csignal>
#include <unistd.h>

void signalHandler(int signal) {
    if (signal == SIGPIPE) {
        std::cerr << "对方已经关闭了连接" << std::endl;
        // 进行相应的处理...
    }
}

int main() {
    signal(SIGPIPE, signalHandler);
    
    // 其他代码...
    
    return 0;
}
```

在上述示例中，当接收到 SIGPIPE 信号时，会调用 signalHandler() 函数进行处理。可以根据具体需求在 signalHandler() 中编写对方主动断开时的逻辑。

通过以上方式，客户端和服务端都能够检测到对方的主动断开，并能够及时进行处理，以保证网络连接的正常运行。

# cmake 设置debug模式
```
cmake -DCMAKE_BUILD_TYPE=Debug -B build
或者
set(CMAKE_BUILD_TYPE "Debug")
```

# Linux环境崩溃生成core文件以及调试 
https://www.cnblogs.com/jing1617/p/8486407.html
https://www.cnblogs.com/zhanggaofeng/p/11945972.html
https://www.answerywj.com/2022/12/20/generate-and-usage-of-core-in-linux
```
# 确认当前会话是否支持产生core文件，0表示不会
ulimit –c

# 打开coredump
ulimit -c unlimited

# 修改coredump文件名格式及存储路径
# %e 可执行文件名
# %p pid
# %t unix时间戳
echo /tmp/core.%e.%p.%t > /proc/sys/kernel/core_pattern

# 用gdb打开程序后再加载coredump, bt查看堆栈
gdb ./test
core-file ./core
bt
```

# wsl以root启动
https://www.jianshu.com/p/e43e11d6ba09
```
# 以root身份登陆
wsl --user root

# 列出已注册wsl子系统
wslconfig /l

# 以root身份登陆指定子系统
wsl -d kali-linux --user root
```

# 端口复用问题
```
int opt = 1;
setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, (const void *)&opt, sizeof(opt));
```

# 粘包问题（Packet Concatenation Problem）
Q: 什么是粘包问题，请提供一个解决粘包问题的c++例子，需要包含服务端和客户端，要求可以在Linux环境运行，不能使用固定长度或者特殊分隔符这两种方法
A: 粘包问题（Packet Concatenation Problem）是指在网络通信中，由于数据传输的特性，多个数据包可能会连在一起形成一个较大的数据块，导致接收方无法正确解析和处理这些数据。

要解决粘包问题，可以使用消息长度字段来表示每个数据包的长度，以便接收方可以准确地切分数据。下面是一个使用消息长度字段解决粘包问题的 C++ 示例，涉及一个基于 TCP 协议的服务端和客户端

## socket类型
* SOCK_STREAM   tcp
* SOCK_DGRAM    udp
* SOCK_RAW      raw，可以指定IP头部

## socket通信流程
* TCP和UDP互不干扰，系统可以同时开启TCP和UDP的80端口
* socket不属于任何一层网络协议，它只是对tcp层的封装
* 注意字节序转换，htonl/htons 或 ntohl/ntohs

### TCP
* Server：socket() -> bind() -> listen() -> accept() -> read() -> write() -> close()
* Client：socket() -> connect() -> write() -> read() -> close()

### UDP
* Server：socket() -> bind() -> recvfrom() -> sendto() -> close()
* Client：socket() -> sendto() -> recvfrom() -> close()

## 同步阻塞模型
* 没有客户端连接则阻塞在accept
* 和客户端同步消息时会阻塞在read和write

## 多进程并发模型
* 有客户端连接时，开启新的进程来处理与这个客户端的数据交互
* 连接数多时服务端负担过重

## 多线程并发模型

## IO多路复用模型


# 来自C++之父Bjarne Stroustrup的人生建议
https://mp.weixin.qq.com/s/UXboQwm8JJ01pqZNUTFkXw
* 不要过度专业化，不要太笃定自己的未来
* 不能只写代码，花时间拥有平衡的生活
* 为机会做好准备，接受基础广泛的教育，基础广泛的技能

# 系统调用与函数调用有什么区别
https://mp.weixin.qq.com/s/iB5HzcjTRNcpgJi8FKLj_w
* 函数调用对应系统指令为call + 指令执行地址
* 系统调用对应为syscall + 指令序号
* 如果call执行了一个系统函数地址，cpu会判断当前进程没有权限，没有的话会被kill掉
* 系统调用时cpu会进入专用的内核栈区，每个进程都有两个栈，一个系统栈，一个用户栈，分别对应内核态和用户态

# 肉桂卷01
https://www.xiaohongshu.com/explore/6358b8dd000000001502e9ef
1. 免揉面团
温牛奶130g
干酵母3g
高筋面粉200g
糖15g
盐4g
黄油15g

2. 肉桂酱：
红糖30g - 20g
肉桂粉5g - 10g
黄油25g

3. 发酵：30° 45分钟
两倍大后，直接擀开，不要揉，擀成25cm*30cm大小
均匀摸酱，卷起来，蘸水封口
均分8块
30° 30分钟，1.5-2倍大

4. 刷牛奶，撒坚果碎，烤箱提前10分钟预热，180°烤20分钟

5. 烤好后淋上乳酪酱：
糖粉20g
牛奶13g
奶油奶酪10g

6. 最后撒上糖粉

# 肉桂卷02
https://www.xiaohongshu.com/explore/644a42450000000013036c4e
1. 免揉面团
牛奶150g
酵母3g
全麦面粉100g
高筋面粉100g
盐2g
糖15g
黄油15g

2. 发酵30°40分钟
3. 肉桂酱
肉桂粉5g
红糖20g
黄油25g

4. 按压排气，擀成长方形35cm*25cm
肉桂酱抹匀，卷起来，切成6份

5. 发酵30°40分钟，1.5倍大
6. 抹上牛奶，烤箱180°烤20分钟


# 智能指针解决了什么问题
https://www.geeksforgeeks.org/smart-pointers-cpp/
* Memory leak 内存泄漏，指针不再使用了但没释放内存
* Dangling Pointers 悬挂指针，指针指向的内存被释放了，但是指针没置零
* Wild Pointers 野指针，指针指向的内容不再有效，或者指针没有初始化
* Buffer Overflow 缓冲区溢出，通过指针写入分配内存之外的内存

# 如何做Code Review
https://mp.weixin.qq.com/s/HoFSNCd1U3eoUqYaQiEgwQ
所谓架构师，就是掌握大量设计理念和原则、落地到各种语言及附带工具链（生态）下的实践方法、垂直行业模型理解，定制系统模型设计和工程实践规范细则，进而控制30万+行代码项目的开发便利性、可维护性、可测试性、运营质量的资深研发群体。

* 对于代码格式规范，100%严格执行，眼中容不得一点沙。
* 文件绝不能超过 800 行，超过一定要思考怎么拆文件。工程思维，就在于拆文件的时候积累。
* 函数对决不能超过 80 行，超过一定要思考怎么拆函数，思考函数分组，层次。工程思维，就在于拆文件的时候积累。
* 代码嵌套层次不能超过 4 层
* 不懂就问，不怕低级问题
* 只打关键日志
* 代码复用，消灭重复
* 坚持主干开发
* 坚持原则

## 代码变坏的根源
* 重复代码问题
* 过长的代码块，50行以上
* 过大的文件，500+行
* 避免过度封装，少用继承，多用组合



# 介绍一下现代计算机图形高效渲染的方法论
现代计算机图形高效渲染是指通过优化算法和技术，以最小的计算资源和时间生成逼真且高性能的图像输出。以下是一些现代计算机图形高效渲染的方法论：

1. 并行计算：利用现代图形硬件（如GPU）的并行计算能力，将渲染任务分解为多个并行子任务，并同时执行它们。这样可以提高渲染的速度和效率。

2. 渲染管线优化：图形渲染通常包括多个阶段，如顶点处理、三角形剪裁、光栅化、片段处理等。通过对渲染管线中各个阶段进行优化，如使用更高效的数据结构和算法、减少不必要的计算和内存访问等，可以提高渲染性能。

3. 着色器优化：着色器是渲染管线中的重要组成部分，负责模拟光照、纹理贴图、阴影等效果。通过优化着色器算法和数据布局，可以减少计算复杂度和内存访问，提高着色器执行效率。

4. 纹理压缩：高分辨率纹理占据大量的显存带宽和存储空间。通过使用纹理压缩算法（如基于块的压缩算法）对纹理进行压缩，可以减少内存带宽和存储需求，提高渲染效率。

5. 裁剪和可视性检测优化：在渲染过程中，通过裁剪和可视性检测技术排除不可见的对象和图元，可以减少不必要的渲染工作，提高渲染性能。

6. Level of Detail（LOD）技术：针对远离相机的对象，可以使用较低细节级别的模型和纹理来代替高细节级别的模型和纹理，以减少计算和内存开销，同时保持一定程度的渲染质量。

7. GPU计算：利用GPU的通用计算能力，将一些与图形渲染相关的计算任务移至GPU执行，例如物理模拟、粒子系统、阴影计算等。这样可以释放CPU负担，提高整体的渲染性能。

8. 前向渲染与延迟渲染：前向渲染适合处理少量光源和非复杂场景，而延迟渲染适合处理大量光源和复杂场景。根据具体需求选择合适的渲染技术，以提高渲染性能。

除了上述方法，还有很多其他的优化技术和算法可用于高效渲染。在实际应用中，根据具体场景和需求，可以结合多种技术和策略进行综合优化，以达到更好的图形渲染性能。

# 线程池
https://www.cnblogs.com/carsonzhu/p/16799198.html
* 基本实现
```
class ThreadPool {
public:
    explicit ThreadPool(size_t threads = std::thread::hardware_concurrency());
​
    template<typename F, typename... Args>
    auto enqueue(F &&f, Args &&...args);
​
    ~ThreadPool();
​
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;
};
```
## 线程池大小如何设置
* CPU密集型任务：频繁切换上下线程是不明智的，此时应该设置一个较小的线程数，比如CPU的数目加1；
* IO密集型任务：IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1。

## 配置线程池大小的原则-阻抗公式
```
N = CPU数量
P = CPU繁忙时间 / 总运行时间   // 0 < P <=1
T = 所需设置线程数
T = N / P
```

## OpenAI：阻抗公式
在线程池中，阻抗公式不是一个常见的概念。线程池是一种并发编程技术，用于管理和复用线程资源，以提高应用程序的性能和响应能力。它通常包含了以下几个关键参数：

并行度（Parallelism）：表示线程池中同时执行任务的线程数量。较高的并行度可以提高任务的并发执行能力，但也会增加线程调度和资源开销。
最大线程数（Max Threads）：线程池允许创建的最大线程数量。超过此数量的任务将排队等待执行。
队列容量（Queue Capacity）：线程池任务队列可以容纳的最大任务数。当任务数量达到队列容量时，新的任务将被拒绝或采取其他策略进行处理。
饱和策略（Saturation Policy）：用于处理任务提交速度超过线程池处理能力的情况。常见的饱和策略包括直接执行、拒绝任务、丢弃任务等。
这些参数会影响线程池的性能和效率，但没有一个明确的公式来描述它们之间的关系为阻抗公式。线程池的设计和调优通常需要根据具体应用场景和需求进行调整和优化。

在实际使用线程池时，你可以根据任务的特性、系统资源和性能需求来选择并行度、最大线程数以及队列容量等参数。通过合理的配置和监测，可以避免线程池过载或资源浪费，提高应用程序的性能和效率。


# 字节序
https://www.ruanyifeng.com/blog/2016/11/byte-order.html
* 大端序：高位字节存储在地址的低位
* 小端序：高位字节存储在地址的高位

* 32位整数的求值公式
```
/* 大端字节序 */
i = (data[3]<<0) | (data[2]<<8) | (data[1]<<16) | (data[0]<<24);

/* 小端字节序 */
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
```

## 在不同的场景下，使用大端序或小端序可能有不同的原因和考虑因素。下面是几个常见的场景和相应的原因：

处理器架构：某些处理器架构天生支持大端序或小端序。例如，PowerPC 和 Motorola 68k 处理器使用大端序，而 x86 和 ARM 处理器使用小端序。在这种情况下，选择大端序或小端序是为了与特定的处理器架构保持兼容。

网络通信：在网络通信中，数据包往往要在不同的主机和操作系统之间传输。为了确保数据的正确解释，网络协议通常规定使用特定的字节序。例如，TCP/IP 协议规定使用大端序进行数字类型的数据传输。因此，在网络通信中使用大端序可以简化数据转换和协议实现。

存储和持久化：将数据存储到磁盘或其他持久化媒体时，可能需要考虑平台的字节序。如果数据是以固定字节序存储的，那么可以在不同平台上简单地读取和解释这些数据。这在数据共享、数据备份和跨平台开发中非常有用。

数据格式标准：某些数据格式标准（如文件格式、图像格式、音频格式等）可能要求使用特定的字节序。这是为了确保跨平台兼容性和正确解析数据。开发者需要遵循相应的标准规范，以便正确地存储和解释这些数据。

总之，选择大端序或小端序取决于具体的场景需求、处理器架构、网络协议和数据格式标准等因素。在实际开发中，了解所使用的系统和平台的字节序规则，并根据需要进行正确的转换和处理，是确保数据一致性和可移植性的关键。

# c++网络编程中，如何对弱网进行优化
在 C++ 网络编程中，你可以采取以下方法对弱网络进行优化：
* 超时设置：为网络操作设置适当的超时时间。如果网络连接或操作超过设定的超时时间仍未完成，可以中断操作或进行错误处理。这样可以避免长时间等待导致程序阻塞。
* 进行并发操作：使用多线程或异步操作来并发处理多个网络请求。这样可以减少网络请求之间的等待时间，提高网络传输效率。
* 使用非阻塞IO或事件驱动模式：将网络套接字设置为非阻塞模式，并使用 select、poll、epoll 等异步 IO 或事件驱动模型进行网络操作。这样可以实现异步处理，提高网络响应速度。
* 减小数据传输量：优化数据传输的大小，可以通过压缩、协议优化等方式减小数据的传输量。例如，使用压缩算法对数据进行压缩，在网络上传输较小的数据包，从而提高传输效率。
* 断点续传机制：对于大文件或大数据量的网络传输，可以实现断点续传机制，即在网络中断后能够从断点处继续传输，而不必重新传输整个文件或数据。
* 优化网络协议：针对具体的网络场景，可以优化网络协议以适应弱网环境。例如，使用 TCP 协议的带宽自适应算法、拥塞控制等机制来减少网络丢包和重传。
* 数据缓存：在弱网络环境下，可以使用缓存技术对数据进行临时存储，等待网络恢复后再进行传输。这样可以提高用户体验，减少网络传输中断对程序的影响。
* 错误处理与重试机制：对于网络操作的错误，要进行合理的错误处理，并实现重试机制。当网络连接失败或操作超时时，可以尝试重新连接或重复操作，直到成功为止。

通过以上优化方法，你可以使 C++ 网络应用程序在弱网络环境中具有更好的性能和可靠性，提高用户体验和程序的稳定性。根据具体的需求和场景，选择适合的优化策略进行应用。

# 对于一个c++视频服务端，如果对弱网条件下进行优化
对于一个 C++ 视频服务端，在弱网络条件下进行优化的一些方法包括：

* 压缩和优化视频传输：使用压缩算法对视频数据进行压缩，以减小视频数据的传输量。例如，可以使用视频编码标准（如 H.264）对视频进行压缩，并在传输过程中使用流式传输以逐渐播放视频。
* 自适应码率调整：针对弱网条件，实现自适应码率调整机制，根据当前网络状况动态选择合适的视频码率。这样可以在网络带宽不稳定或较低的情况下保持视频播放的流畅性。
* 预加载和缓存：在弱网络条件下，预加载视频数据并缓存一部分视频内容。这样可以通过提前加载视频数据和缓存来减少对网络的依赖，提高用户体验。
* 错误处理和重传机制：对于视频数据的传输错误，实现错误处理和重传机制。当网络条件差或丢包时，及时发起重传请求，确保视频数据的完整性和准确性。
* 流控制和拥塞控制：实现流控制和拥塞控制机制，根据网络状况调整视频数据的传输速率，防止网络拥塞和丢包情况的发生。
* 缓冲区管理：通过合理管理接收和发送缓冲区，确保视频数据的流畅传输。在网络环境差的情况下，增加接收缓冲区的大小，以减少丢包的可能性。
* 优化网络连接和握手过程：通过优化服务器端的网络连接和握手过程，减少握手时间和建立连接所需的网络开销，提高网络响应速度。
* 实时监测和统计：监测网络条件和视频传输的性能指标，例如延迟、丢包率等，进行实时统计和监控。根据统计结果调整优化策略，以适应不同的弱网络条件。

通过以上优化方法，你可以提高 C++ 视频服务端在弱网络条件下的稳定性和性能，保证视频的流畅播放和用户体验。需要根据具体的应用场景和需求选择适当的优化策略，并进行测试和调优，以获得最佳效果。

# 什么是弱网抖动策略
弱网抖动策略是一种针对弱网络条件下的抖动（即网络延迟的变化幅度较大）进行应对的优化策略。在弱网环境中，网络延迟可能会频繁变化，导致数据传输的不可预测性和不稳定性。
* 弱网抖动策略旨在减少因网络抖动引起的问题，以提高网络传输的效果和可靠性。以下是几种常见的弱网抖动策略：
* 缓冲区管理：通过增加接收缓冲区的大小来处理网络抖动。当网络延迟增加时，较大的接收缓冲区可以缓冲更多的数据，以避免数据丢失或应用程序阻塞。
* 抖动缓冲：引入抖动缓冲来平滑网络延迟的变化。抖动缓冲会暂时存储接收到的数据，在网络抖动较大时提供一个平滑的数据流输出。
* 重传和丢包处理：当发生数据包丢失时，采取相应的重传机制来确保数据的完整性。例如，使用重传请求或前向错误纠正等技术来纠正由网络抖动引起的数据丢失。
* 自适应码率调整：根据网络抖动情况动态调整视频或音频的传输码率。通过降低码率可以减少对网络带宽的需求，以适应网络延迟的变化。
* 流控制和拥塞控制：采用流控制和拥塞控制算法来平衡数据发送和接收之间的速度，以避免网络抖动导致的拥塞和丢包现象。
* 错误纠正和冗余机制：引入冗余数据和错误纠正技术来应对网络抖动带来的数据丢失和损坏。这些机制可以提供更高的数据可靠性，确保数据的正确传输。

通过采用弱网抖动策略，可以有效应对弱网络环境下的抖动问题，提高网络传输的稳定性和可靠性。具体的策略选择和实施方式需要根据应用场景和需求来确定，并进行测试和调优以获得最佳效果。


# c++网络编程如何设计错误纠正和冗余机制
在 C++ 网络编程中，设计错误纠正和冗余机制需要考虑数据包的发送、接收和检验过程。以下是一种常见的实现方法，以数据校验和作为示例：

1. 发送端设计：
    * 在发送端，将要发送的数据按照一定的规则进行划分，并计算数据校验和。
    * 在数据包中添加一个校验和字段，用于存储计算得到的校验和。
    * 将数据包发送给接收端。
2. 接收端设计：
    * 在接收端，接收到数据包后，提取数据和校验和字段。
    * 对接收到的数据重新计算校验和值。
    * 将计算得到的校验和与接收到的校验和进行比较。
    * 如果两个校验和相同，则说明数据包没有错误，可以继续处理该数据。
    * 如果校验和不匹配，则说明数据包可能存在错误。
4. 错误处理和重传：
    * 如果发现数据包的校验和不匹配，可以触发错误处理和重传机制。
    * 发送端可以通过接收到的确认或反馈信息来确定需要重新发送的数据包，并进行重传操作。
    * 接收端在接收到重传的数据包后，再次进行校验和比较，直到校验和匹配为止。
5. 冗余机制：
    * 为了增加数据的冗余性，可以引入冗余数据来应对网络错误。
    * 发送端可以在每个数据包中添加冗余数据，例如通过重复发送相同的数据或添加冗余校验码等。
    * 接收端接收到多个冗余数据时，可以进行冗余校验操作，以保证数据的完整性和正确性。

需要注意的是，以上是一种简单的示例，实际实现错误纠正和冗余机制可能需要根据具体情况进行调整。例如，可以使用更强大的差错检测和纠正算法（如循环冗余校验码 CRC），或者结合其他技术和协议（如前向纠错编码 FEC）来提高数据的可靠性和容错性。

此外，在设计错误纠正和冗余机制时，还应考虑网络延迟、带宽和系统资源等因素，以平衡数据传输的效率和可靠性。


# 请模拟一次高级c++网络工程师面试
当然，我可以模拟一次高级 C++ 网络工程师的面试。以下是一些常见的问题，你可以回答并提供你的解决方案。

1. 请解释 TCP 和 UDP 的区别，并提供适用场景。

答：TCP（传输控制协议）和 UDP（用户数据报协议）都是在网络通信中常用的传输层协议。主要区别如下：

* TCP 是面向连接的，提供可靠的、有序的、基于字节流的通信；UDP 是无连接的，不保证数据的可靠性和顺序性。
* TCP 提供错误检测、重传机制和流量控制；UDP 不提供这些机制，仅提供最小的错误检测功能。
* TCP 的开销较大，因为需要建立和维护连接状态；UDP 的开销较小，因为无需建立连接。

适用场景：

* TCP 适用于对数据可靠性要求高、顺序要求严格的应用，如文件传输、电子邮件等。
* UDP 适用于实时性要求高、数据丢失可容忍的应用，如音视频传输、实时游戏等。

2. 解释 TCP 的三次握手过程。

答：TCP 的三次握手过程用于在发送端和接收端之间建立可靠的连接。具体步骤如下：

* 第一次握手：发送端向接收端发送一个 SYN（同步）报文段，指示发送端请求建立连接。
* 第二次握手：接收端收到 SYN 报文段后，会发送一个 ACK（确认）报文段作为响应，并发送一个自己的 SYN 报文段。
* 第三次握手：发送端收到接收端的 ACK 报文段和 SYN 报文段后，会发送一个 ACK 报文段作为最后的确认。

随着三次握手的完成，连接的双方都知道彼此已准备好进行通信。这种握手过程确保了双方都能在连接建立之前进行同步和确认，从而确保连接的可靠性和完整性。

3. 你如何处理网络中的粘包问题？

答：网络中的粘包问题可以通过以下方法来处理：

* 使用固定长度的消息：发送端将数据分割成固定大小的消息，在接收端按照相同大小的缓冲区接收和处理。
* 使用特殊字符进行分隔：在每个消息的末尾添加一个特殊字符（如换行符或空格），接收端根据特殊字符将消息分割开。
* 使用消息长度字段：在消息的头部添加一个表示消息长度的字段，接收端先读取长度字段，然后根据长度读取相应大小的数据。

这些方法都需要发送端和接收端遵循相同的消息分割规则，以确保准确地分割和处理消息，从而解决粘包问题。

4. 如何实现长连接？

答：实现长连接可以使用以下方法：

* 保持连接打开状态：在发送和接收数据之后，保持 TCP 或 UDP 连接处于打开状态，以便后续的数据交换。
* 心跳机制：定时向对方发送特定的心跳消息，以确认连接的有效性。如果一段时间内未收到心跳响应，则断开连接。
* 断线重连：当连接断开时，可以尝试重新连接服务器，并恢复之前的会话状态。

注意：长连接可能会占用服务器资源，因此需要在设计时考虑到连接的管理和资源消耗。

这些问题只是面试中的一小部分，希望对你进行模拟面试有所帮助。请根据你的实际经验和知识回答这些问题，并展示你在 C++ 网络编程方面的专业知识。祝你好运！

# 既然getsockopt可以检测tcp连接是否断开，为什么还需要设计心跳包
确实，可以使用getsockopt函数的SO_ERROR选项来检测TCP连接是否断开。该方法可以通过查询套接字状态来确定连接状态，但它只提供一次快速的连接状态检查，不能实时地监测连接是否保持活跃。

设计心跳包的原因主要有以下几点：

1. 实时性：getsockopt只提供了一次连接状态的检查，而心跳包可以通过定期发送并等待对方回复来实时监测连接的存活状态。通过设置适当的心跳间隔，可以更及时地发现连接中断或异常情况。
2. 网络设备限制：某些网络设备（如防火墙或代理服务器）可能会过滤或丢弃某些特定类型的数据包，导致对于getsockopt来说，连接看起来仍然是有效的，但实际上已经无法正常通信。发送心跳包可以绕过这些限制，确保连接的可靠性。
3. 应用层控制：心跳包是在应用层上实现的，可以根据具体应用的需求和场景进行灵活的设计。例如，可以自定义心跳包的格式和内容，以便在心跳包中携带一些业务相关的信息，进一步验证对方节点的可用性或状态。
4. 报文交互：心跳包通常是双向的，需要对方节点接收并回复。通过心跳包的交互，可以确保连接的双向通信的正常性，而不仅是简单地检查连接状态。

总的来说，尽管可以使用getsockopt函数来检测TCP连接的状态，但设计心跳包可以提供更实时、可靠和灵活的连接监测和维护。它可以应对一些特殊情况下的网络限制，并允许应用层控制和自定义。

# 心跳包机制
https://zhuanlan.zhihu.com/p/626960589
* 长时间没有数据往来，可能会被防火墙程序关闭连接
* 连接链路中的关键路由器或者交换机故障，无法及时感知到连接是否正常，即“死链”问题

- 心跳包可用来保活以及检测死链（及时关闭socket，回收连接资源）
- 一般客户端应主动给服务端端发送心跳包，服务端应答心跳包
- 心跳包也可以携带一些业务数据
- 心跳包间隔可按需设置15s-45s不等

## TCP keepalive 选项
```
//on 是 1 表示打开 keepalive 选项，为 0 表示关闭，0 是默认值
int on = 1;
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on))

//发送 keepalive 报文的时间间隔
int val = 7200;
setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val));

//两次重试报文的时间间隔
int interval = 75;
setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(interval));

// 如果重试 9 次（TCP_KEEPCNT 值）（前后重试间隔为 75 秒（TCP_KEEPINTVL 值））仍然不可达，则向应用程序返回 ETIMEOUT（无任何应答）或 EHOST 错误信息。
int cnt = 9;
setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));
```


# addrinfo
```
struct addrinfo {
    int ai_flags;           // 地址标志
    int ai_family;          // 地址族
    int ai_socktype;        // 套接字类型
    int ai_protocol;        // 协议
    socklen_t ai_addrlen;   // 地址长度
    struct sockaddr* ai_addr;  // 地址数据结构
    char* ai_canonname;     // 规范主机名
    struct addrinfo* ai_next;   // 指向下一个结果的指针
};
```
* ai_flags指定了一些地址获取的选项标志，如AI_PASSIVE表示适用于服务器端。
* ai_family指定了地址族（Address Family），例如AF_INET表示IPv4，AF_INET6表示IPv6。
* ai_socktype指定了套接字类型（Socket Type），如SOCK_STREAM表示流式套接字。
* ai_protocol指定了套接字使用的协议（Protocol），如IPPROTO_TCP表示TCP协议。
* ai_addrlen是地址长度（Address Length）。
* ai_addr指向sockaddr结构体的指针，包含了实际的地址信息。
* ai_canonname是规范主机名（Canonical Host Name），即主机名的规范格式。
* ai_next是一个指向下一个addrinfo结构体的指针，用于遍历多个结果。

ai_flags（地址标志）：
    取值范围：可以使用零或以下标志的按位或组合：
        AI_PASSIVE：适用于服务器端，表示用于监听连接的地址。
        AI_CANONNAME：返回一个规范主机名。
    含义：指定地址获取的选项标志。

ai_family（地址族）：
    取值范围：
        AF_UNSPEC：不限定地址族，允许IPv4或IPv6。
        AF_INET：IPv4地址族。
        AF_INET6：IPv6地址族。
    含义：指定地址族类型。

ai_socktype（套接字类型）：
    取值范围：
        SOCK_STREAM：流式套接字，提供可靠的、面向连接的通信。
        SOCK_DGRAM：数据报套接字，提供不可靠的、无连接的通信。
        SOCK_RAW：原始套接字，提供对网络层以上协议的直接访问。
    含义：指定套接字类型。

ai_protocol（协议）：
    取值范围：根据套接字类型的不同，可以使用协议号常量（如IPPROTO_TCP、IPPROTO_UDP）或设置为零表示默认协议。
    含义：指定套接字使用的协议。

ai_addrlen（地址长度）：
    取值范围：某个特定平台上地址结构体的大小。
    含义：指定地址长度。

ai_addr（地址数据结构）：
    取值范围：指向一个sockaddr结构体的指针，其中存储了实际的地址信息。
    含义：指定地址信息。

ai_canonname（规范主机名）：
    取值范围：字符串指针，可能为NULL。
    含义：返回规范化的主机名。

ai_next（下一个结果）：
    取值范围：指向下一个addrinfo结构体的指针，可能为NULL。
    含义：用于遍历多个解析结果，形成链表。


# struct sockaddr
```
struct sockaddr {
    sa_family_t sa_family;  // 地址族，用于指定地址的类型
    char sa_data[14];       // 地址数据，具体内容与地址族相关
};
```

sa_family：
    类型：sa_family_t
    取值范围：根据地址族的不同而变化，常见的取值有 AF_INET（IPv4）、AF_INET6（IPv6）和 AF_UNIX（Unix 域）
    含义：用于指定地址的类型或族，决定了 sa_data 字段中存储的具体地址数据的形式。

sa_data：
    类型：char[14]
    取值范围：具体内容与地址族相关，不同的地址族可能会使用不同的数据结构存储地址信息。
    含义：存储地址的实际数据，其格式和含义取决于地址族类型。例如，在 IPv4 地址族中，前4个字节存储 IP 地址，后2个字节存储端口号。

需要注意的是，struct sockaddr 是一个通用的结构体，在实际编程中，可能会使用它的具体派生类型来表示特定类型的地址，如 struct sockaddr_in 用于表示 IPv4 地址，struct sockaddr_in6 用于表示 IPv6 地址，struct sockaddr_un 用于表示 Unix 域地址等。这些派生类型在具体应用场景中定义了更多的字段，以便存储相应地址族的具体信息。

## struct sockaddr_in
```
struct sockaddr_in {
    sa_family_t     sin_family; // 地址族，通常为 AF_INET（IPv4）
    in_port_t       sin_port;   // 16 位端口号
    struct in_addr  sin_addr;   // 32 位 IP 地址
    char            sin_zero[8]; // 填充字段，通常设置为全 0
};
```

sin_family 字段：
    取值范围：AF_INET（IPv4 地址族）。
    含义：指定地址族类型，用于确定 sockaddr_in 结构体的具体含义。
sin_port 字段：
    取值范围：0~65535。
    含义：表示 IPv4 地址中的 16 位端口号。
sin_addr 字段：
    类型：struct in_addr
    取值范围：32 位无符号整数。
    含义：表示 IPv4 地址中的 32 位 IP 地址。
sin_zero 字段：
    类型：char[8]
    取值范围：没有特殊限制。
    含义：用于填充字段，通常设置为全 0。

## struct sockaddr_in6
```
struct sockaddr_in6 {
    sa_family_t     sin6_family;   // 地址族，通常为 AF_INET6（IPv6）
    in_port_t       sin6_port;     // 16 位端口号
    uint32_t        sin6_flowinfo; // 流信息
    struct in6_addr sin6_addr;     // 128 位 IPv6 地址
    uint32_t        sin6_scope_id; // 作用域 ID
};
```

sin6_family 字段：
    取值范围：AF_INET6（IPv6 地址族）。
    含义：指定地址族类型，用于确定 sockaddr_in6 结构体的具体含义。
sin6_port 字段：
    取值范围：0~65535。
    含义：表示 IPv6 地址中的 16 位端口号。
sin6_flowinfo 字段：
    取值范围：32 位无符号整数。
    含义：用于流控制和服务质量(QoS)相关的标识。
sin6_addr 字段：
    类型：struct in6_addr
    取值范围：128 位二进制数，表示 IPv6 地址。
    含义：表示 IPv6 地址中的 128 位 IP 地址。
sin6_scope_id 字段：
    取值范围：32 位无符号整数。
    含义：用于指定接口的作用域 ID，通常在连接到链接本地地址时使用。

## struct sockaddr_un
```
struct sockaddr_un {
    sa_family_t sun_family; // 地址族，通常为 AF_UNIX（Unix 域）
    char        sun_path[108]; // 文件路径名
};
```

sun_family 字段：
    取值范围：AF_UNIX（Unix 域地址族）。
    含义：指定地址族类型，用于确定 sockaddr_un 结构体的具体含义。
sun_path 字段：
    类型：char[108]
    取值范围：没有特殊限制。
    含义：表示 Unix 域套接字对应文件的路径名。
